# 「1」简介&核心概念

[TOC]



## 一、数据库比对

```
* MySQL
	在数据较少的情况下，查询速度较快，支持事务管理
	单节点单机，存储数据量有限
* HBase
	大数据分布式数据库，可以存储海量数据
	不太支持sql
	经常使用hbase存储标签数据，key-value模式
* Hive
	良好的语法和窗口函数，适合做分析报表以及统计
	实时性不高
```

## 二、简介

```
1）OLAP（联机分析）列式数据库管理系统
2）在线分析处理查询
3）名字：click Stream data warehouse
4）用于处理实时数据，关于事件，快速
5）分布式数据库，支持线性扩展，简单方便、高可靠性、容错
6）它在大数据领域没有走Hadoop生态，而是采用Local attached storage,在整个IO就没有Hadoop那一套的局限。
```

## 三、优点和缺点

```
**优点**
1. 灵活的MPP架构，支持线性扩展，简单方便，高可靠性
2. 多服务器分布式处理数据，完备的DBMS系统
3. 底层数据劣势存储，支持压缩，优化数据存储，优化索引数据，优化底层存储
4. 容错跑分快：比Vertica快5倍，比Hive快279倍，比Mysql快800倍，其可处理的数据级别已经达到10亿级别
5. 功能多：支持数据统计分析各种场景，支持类SQL查询，异地复制部署
	海量数据存储，分布式运算，快速闪电的性能，几乎实时的数据分析，友好的SQL语法，出色的函数支持

**缺点**
1. 不支持事务，不支持真正的删除/更新
2. 单节点不支持高并发，官方建议qps为100，可以通过修改配置文件增加连接数，但那是在服务器足够好的情况下
3. 不支持二级索引
4. 不擅长多表join
5. 元数据管理需要人为干预
6. 尽量做1000以上批量的写入，避免逐行insert或小批量的insert，update，delete操作
```

## 四、应用场景

```
1. 绝大多数请求都是用于读访问的，要求实时返回结果
2. 数据需要以大批次（大于1000行）进行更新，而不是单行更新；或者根本没有更新操作
3. 数据只是追加到数据库，没有必要修改
4. 读取数据时，会从数据库中提取出大量的行，但只用到一小部分列 列式存储
5. 表很“宽”，即表中包含大量的列
6. 查询频率相对较低（通常每台服务器美妙查询数百次或更少）
7. 对于简单查询，允许大约50ms的延迟
8. 列的值是比较小的数值和短字符串（例如，每个URL只有60个字节）
9. 在处理单个查询时需要高吞吐量（每台服务器美妙高达数十亿行）
10. 不需要事务
11. 数据一致性要求较低
12.每次查询中只会查询一个大表。除了一个大表，其余都是小表。
```

## 五、核心概念

### 1）数据分片

```
1. 数据分片是将数据进行横向切粉，这是一种在面对海量数据的场景下，解决存储和查询瓶颈的有效手段，是一种分治思想的体现。
2. ClickHouse支持分片，而分片则依赖集群。每个集群由1到多个分片组成，而每个分片则对应了ClickHouse的1个服务节点。
3. 分片的数量上限取决于节点数量（1个分片只能对应1个服务节点）。
4. ClickHouse并不像其他分布式系统那样，拥有高度自动化的分片功能。
5. ClickHouse提供了本地表（Local Table）与分布式表（Distributed Table）的概念。
6. 一张本地表等同于一份数据的分片，而分布式表本身不存储任何数据，它是本地表的访问代理，起作用类似分库中间件。
7. 借助分布式表，能够代理多个数据分片，从而实现分布式查询。
8. 这种设计类似数据库的分库分表，十分灵活。

例如：在业务系统上线的初期，数据体量并不高，此时数据表并不需要多个分片。所以使用单个节点的本地表（单个数据分片）即可满足业务需求，待到业务增长、数据量增大的时候，再通过新增数据分片的方式分流数据，并通过分布式表实现分布式查询。这就好比一辆手动挡赛车，它将所有的选择权都叫到了使用者手中！
```

### 2）列式数据库更适合OLAP场景的原因

```
列式数据库更适合于OLAP场景(对于大多数查询而言，处理速度至少提高了100倍)，下面详细解释了原因(通过图片更有利于直观理解)：
```

**行式**

![Row oriented](https://raw.githubusercontent.com/DataDevLPY/TyporaPicStore/main/Picturerow-oriented.gif?token=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)

**列式**

![Column oriented](https://raw.githubusercontent.com/DataDevLPY/TyporaPicStore/main/Picturecolumn-oriented-20211121214611403.gif?token=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)

### 3) 向量化

```
CLickHouse不仅将数据按列存储，而且按列进行计算。传统OLTP数据库通常采用按行计算，原因是事务处理中以点查为主，SQL计算量小，实现这些技术的收益不够明显。但是在分析场景下，单个SQL所涉及计算量可能极大，将每行作为一个基本单元进行处理会带来严重的性能损耗：
	1）对每一行数据都要调用相应的函数，函数调用开销占比高；
	2）存储层按列存储数据，在内存中也按列组织，但是计算层按行处理，无法充分利用CPU cache的预读能力，造成CPU Cache miss严重
	3）按行处理，无法利用高效的SIMD指令
			ClickHouse实现了向量执行引擎（Vectorized execution engine），对内存中的列式数据，一个batch调用一次SIMD指令（而非每一行调用一次），不仅减少了函数调用次数，降低了cache miss，而且可以充分发挥SIMD指令的并行能力，大幅度缩短了计算耗时。向量执行引擎，通常能够带来数倍的性能提升。
			（SIMD全程Single Instruction Multiple Data，单指令多数据流，能够复制多个操作数，并把他们打包在大型寄存器的一组指令					集。以同步方式，在同一时间内执行同一条指令）。
```

### 4) 副本

```
数据存储副本，在集群模式下实现高可用，简单理解就是相同的数据备份，在CK中通过复制集，我们实现保障了数据可靠性外，也通过多副本的方式，增加了CK查询的并发能力。这里一般有2种方式：
​	（1）基于ZooKeeper的表复制方式
​	（2）基于Cluster的复制方式。
由于我们推荐的数据写入方式本地表写入，禁止分布式表写入，所以我们的复制表只考虑ZooKeeper的表复制方案。
```

### 5) 引擎

```
不同的引擎决定了表数据的存储特点和表数据的操作行为：
​	（1）决定表存储在那里以及以何种方式存储
​	（2）支持哪些查询以及如何支持
​	（3）并发数据访问
​	（4）索引的使用
​	（5）是否可以执行多线程请求
​	（6）数据复制参数
​	（7）并发操作
表引擎决定了数据在文件系统中的存储方式，常用的也是官方推荐的存储引擎MergeTree系列，如果需要数据副本的话可以使用ReplicatedMergeTree系列，相当于MergeTree的副本版本。读取集群数据需要使用分布式表引擎Distribute
```













